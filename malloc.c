/* Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove() */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//ф-я будет возвращать указатель типа void*(неопределенный указатель), т.е просто адрес
/*на входе будем принимать массив data и длину массива data.Длина будет передоваться через
указатель, потому что длина переменной length будет меняться при добавлении новых данных.
Чтобы мы могли менять ее внутри ф-ии append() мы как раз будем передавать адрес этой
переменной length и работать с ней через указатель.И то же самое для переменной capacity.
value - это то значение , которое мы будем записывать в наш массив.*/
void* append(short *data, size_t *length, size_t *capacity, short value)
{
    /*сделаем проверку.если длина больше capacity,то мы должны увеличить массив в 2 раза*/
    if(*length >= *capacity){
        /*сначала мы саму переменную capacity тоже увеличиваем в 2 раза,раз у нас
        массив физически увеличивается в два раза по длине*/
        (*capacity) *= 2;
        /*и соответственно создать этот новый массив
        возьмем временный указатель *ar и вызовем ф-ию malloc()*/
        short *ar = malloc(sizeof(short) * *capacity);
        //далее делаем проверку на то, взяла ли ф-я malloc() кусок памяти или нет.
        //т/е/ если адрес указателя на массив равен нулю,то что-то пошло не так
        if (ar == NULL){
            //в этом случае вернем указатель на прежний массив и больше ничего не делаем
            return data;
        }
        /*а если все прошло хорошо,тогда мы скопируем все данные из прежнего массива в 
        новый массив.*/ 
        for(int i = 0; i < *length; ++i){
            ar[i] = data[i];
        }
        //далее нам нужно освободить память из прежнего массива на который ведет указатель data
        free(data);
        /*затем после того как мы освободили эту память, этому указателю data нужно присвоить
        адрес нового указателя ar*/
        data = ar;
    }

    /*после того как мы все это сделали, мы дальше делаем следующее: 
    запишем последнее значение в наш массив как новое из переменной value*/
    data[*length] = value;
    //далее *length увеличим на 1,ведь добавился один элемент
    (*length)++;

    //и возвратим адрес data, т.к он может поменяться
    return data;
}

int main(void)
{   
    /*Для самостоятельного выделения памяти из кучи предусмотрены две функции:
    
    void* malloc(size_t size) - для выделения size байт из кучи
    
    void free(void* ptr) - для последующего особождения выделенной памяти*/

    //выделим 10 байт из кучи с помощью malloc()
    char *ar = malloc(10);

    //или выделим 4 байта под тип int
    int *ptr_int = malloc(sizeof(int));

    //или выделим 7 элементов для переменных типа short.
    //будет неделимая область памяти для семи элементов типа short.
    /*Это похоже на массив,но это уже будет указатель не не массив, а указатель на
    неделимую область памяти.*/
    short *ptr_short = malloc(7 * sizeof(short));

    //а в конце программы нужно будет освободитьвсю эту память взятую из кучи
    free(ar);
    free(ptr_int);
    free(ptr_short);

    /*malloc() возвращает либо значение адреса области памяти, либо NULL
    Т.е если по каким-то причинам адрес в куче не смог выделиться с помощью менеджера
    памяти, то ф-я возвращает значение NULL.
    
    
    Далее рассмотрим в каких задачах целесобразно использовать связку malloc() / free()
    
    Предположим, в программе нужно хранить температуру по дням в течении некоторого пе-
    риода.Какой этот период - никто не знает.Это может быть 10 или 2 или 149 дней.
    Как организовать хранение данных в программе? Чтобы с одной стороны не занимать
    слишком много памяти, а с другой стороны разместить все необходимые данные.
    Выход только один - воспользоваться malloc() и free()
    ЛОгика программы будет такая, что сначла мы объявим 2 переменные capacity и length.
    Capacity будет представлять максимально число элементов в массиве, а length - 
    число сохраненных в массив значений. пока length < capacity - проблем никаких нет(новые
    данные можно записывать в массив по порядку),
    но когда вся отведенная под массив память окажется заполненнной, то сделаем прием
    с переворотом(прием с копированием).Мы динамически выделим новый кусок памяти 
    большего размера (к примеру в два раза больше), перенесем туда раннее записанные данные
    из прежнего массива и освободим память из самого первого массива.
    Это известная концепция, положенная в структуру данных под названием ДИНАМИЧЕСКИЙ МАССИВ
    */

    //определим две переменные capacity и length
    size_t capacity = 10;  //начальный размер массива
    size_t length = 0;  //начльное значение 0,потому что у нас нет никаких данных

    /*создадим указатель на наш массив, и для этого воспользуемся ф-ей malloc().В качестве
    аргумента мы укажем число байт, необходимое для нашего массива. Т.к у нас тип short,
    то будет sizeof(short) умножаем на количество элементов этого массива*/
    short *data = malloc(sizeof(short) * capacity); //получаем непрерывную область памяти под наш массив

    /*далее в цикле for мы добавим некоторые данные. пусть счетчик идет от 0 и до 11,
    чтобы мы увидели как это массив увеличивается*/
    for(int i = 0; i < 11; ++i){
        //далее у нас будет ф-я append(),добавляющая новые значения в наш массив
        /*но по сути она будет присваивать массиву другой адресс, если он заполнится
        полностью и мы его увеичили в 2 раза больше,
        или оставлять тот же адрес, если массив не заполнится*/
        data = append(data, &length, &capacity, rand() % 40 - 20); //ф-я реализована выше
    }
    printf("length = %lu, capacity = %lu\n", length, capacity);

    //и посмотрим массив
    for(int i = 0; i < length; ++i){
        printf("%d ", data[i]);
    }

    puts("");
    //и снова не забываем освободить память из под массива data
    free(data);


    /*Эту программу можно улучшить, если знать некоторые дополнительные функции
    для работы с памятью.

    <stdlib.h>
    
    void* calloc(size_t nmemb, size_t size) - выделяет память под nmemb-элементов,
    каждый из которых размером size и автоматически заполняет выделенную память нулями
    Это ключевое ее отличие от ф-ии malloc().В остальном они идентичны.
    
    void* realloc(void *ptr, size_t length) - служит для изменения размера раннее
    выделенной памяти, на которую ведет указатель ptr. А новый размер определяется
    параметром length. Причем если length равен 0, то ф-я realloc будет работать
    аналогично ф-ии free, то есть освободит память.Если же length больше ранее
    выделенной памяти, то ф-я сначала пытается расширить уже существующую область
    до большего размера, но если ей это не удается, то создается новая область
    с копированием всей прежней информации. А предыдущая область памяти автоматически
    особождается.
    
    <string.h>
    
    Следующие две функции предполагаются для и спользования с символьными массивами, т.е
    со строками
    
    void* memcpy(void* restrict dst, const void* restrict src, size_t length); - копирование
    одной строки в другую;

    
    или переносить один фрагмент строки в другой с помощью:
    
    void* memmove(void* dst, const void* src, size_t length)
    
    ключевое слово restrict указывает компилятору,что указатели dst и src уникальны и ведут
    каждый на свою независимую и непересекающуюся область памяти.
    
    В частности, в своей программе выше мы могли бы воспользоваться ф-ей memcpy()
    для копирования данных из массива data в новый массив ar вот так:
    
    просто будет вставка кода
    мы вверху копирование делаем через цикл вот
    
    for(int i = 0; i < *length; ++i){
            ar[i] = data[i];
    }
    
    Через цикл это не самый быстрый процесс.Вместо этого цикла мы воспользуемся
    memcpy()

    memcpy(ar, data, *length * sizeof(short));

    ar - это куда копируем
    data - откуда копируем
    и 3-й аргумент - это количество байт, которое мы копируем

    данная строчка будет работать быстрее,чем копирование через цикл

    Далее мы могли бы еще больше ускорить работу программы.В частности воспользоваться
    не ф-ей malloc() в ф-ии append(), а ф-ей reallock(), которая позволяет увеличить
    размер раннее выделенной памяти

    вместо строчки short *ar = malloc(sizeof(short) * *capacity);
    мы пропишем вот так:

    short *ar = realloc(data, sizeof(short) * *capacity)
    if(ar == NULL){
        return data;
    }
    else{
        data = ar;
    }
    
    1-й аргумент - передаем ту область, которую хотим увеличить
    2-й аргумент - кол-во байт, которое нам требуется
    
    data = ar; - если все прошло правильно,то мы data присваиваем новую область памяти
    ar. Причем в эту новую область памяти уже скопировано значение из старого массива data
    и прежняя память была освобождена, поэтому все начиная
     с memcpy(ar, data, *length * sizeof(short));
    и заканчивая data = ar; можно убрать.
    
    
    
    Вывод: если по каким-то причинам перменные не подходят для хранения данных впрограмме,
    то следует посмотреть в сторону этих функций.Как правило они решают все задачи*/

    return 0;
}