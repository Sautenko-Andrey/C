/*Структуры. Вложенные структуры*/
#include<stdio.h>
#include<string.h>

//пример объявления структуры
struct tag_point {
    int x;
    int y;
    int z;
};

//определим две константы
enum {name_length = 50, b_length = 20, num_length = 3};

//определяем структуру
struct tag_fio {
    char name[name_length];
    char last[name_length];
};

//определим еще одну структуру(вложенную)
struct tag_person {
    struct tag_fio fio;  //в структуре еще одна структура
    char sex;
    unsigned short old;
    char b_date[b_length];
    int fav_nums[num_length];
};

//структура массива
struct numbers {
    int items[num_length];
};

//структура для точек
struct tag_dot {
    double x, y, z;
};

//определение константы max_points
enum min_max_points {min_points = 3, max_points = 10};

//определение констант для футболиста
enum sizes {
    name_size = 25,
    club_size = 22,
    position_size = 10
};

//определение структуры для футболиста
struct footballer {
    char name[name_size];
    char position[position_size];
    char club[club_size];
    unsigned char age;
};


int main(void)
{
    /*На этом уроке познакомимся с еще одним составным типом данных - структурой.
    
    Простой пример объявления структуры для хранения координат точек в трехмерном пространстве.
    смотри вверху.Такая запись логически объединяет x,y,z  в одном новом составном типе данных
    под названием struct tag_point.

    Объявление структуры - это описание нового составного типа в тексте программы и не более
    того.Компилятор здесь не создает никаких новых переменных и не размещает их в памяти. Это
    всего лишь новый тип данных, подобно базовым типам char, short и т.д.

    Раз у нас есть этот тип, то мы можем спокойно объявлять переменную этого типа.*/

    struct tag_point point;

    /*В С тип структуры , к примеру struct tag_point, прописывать обяхательно! 
    Что из себя представляет переменная point  в памяти(на уровне машинных кодов)?
    
    В действительности структура - это абстракция языка Си. В машинных кодах они не сущест-
    вуют. Поэтому когда мы определяем переменную этого типа, о в памяти устройства
    выделяется нужный непрырывный участок из байт, и все поля структуры (ее переменные)
    по порядку распологаются друг за другом. При этом в памяти, где размещаются поля
    структуры, компилятор может самостоятельно добавлять так называемые выравнивающие
    байты. Для чего это нужно? Дело в том что чтение данных из оперативной памяти
    пакетом в 2 или 4 ячейки может происходить быстрее,если читаемые данные расположены
    по четным адресам, и именно по этому компилятор может добавлять выравнивающие байты,
    чтобы переменные размером в машинное слово, попадали на четные адреса. Этот процесс
    называется выравнивание и в результате размер данных в структуре может превышать
    сумму размеров каждого из его полей. 
    
    Истинный размер структуры можно получить следующим образом :*/
    size_t size_point = sizeof(point);
    printf("Size = %zu\n", size_point);

    //или размер можно получить вот так
    size_t size_pointV2 = sizeof(struct tag_point);
    printf("Size = %zu\n", size_pointV2);

    /*После того, как мы объявили переменную на структуру, мы теперь можем заполнить ее
    значениями. Делается это следующим образом:*/

    point.x = 1; //заполняется поле для x
    point.y = 23; //заполняется поле для y
    point.z = 100;  //заполняется поле для z

    /*Точка - это лишь способ обращения к тому или иному полю структуры.
    К примеру выведем на экран то, что у нас получится*/
    printf("x = %d, y = %d, z = %d\n", point.x, point.y, point.z);

    /*Структуры можно так же сразу инициализировать подобно массивам*/

    struct tag_point new_point = {100, 1000, 10000};  //сразу все координаты
    struct tag_point third_point = {222};  //только первая координата 100, отсальные 0
    struct tag_point fourth_point = {};   //все нули

    /*Так же стандарт С99 позволяет делать вот такую ининциализацию*/
    struct tag_point fifth_point = {.y = -12, .z = 1, .x = 200};
    struct tag_point sixth_point = {.y = 20};

    

    /*В качестве полей структуры можно использовать различные типы, в том числе и другие
    структуры. Пример вверху*/

    struct tag_person coworker = {
        {"Andrey", "Sautenko"},     //доп.кавычки для вложенной структуры
        'M',
        33,
        "28.06.1989",
        {7,28,89}
    };
    

    //вывод на печать
    printf("name : %s\n", coworker.fio.name);  //работаем через точку с полями
    printf("name : %s\n", coworker.fio.last);
    printf("sex : %c\n", coworker.sex);
    printf("old : %d\n", coworker.old);
    printf("age : %s\n", coworker.b_date);

    //если мы хотим изменить данные, то делается это тоже через точку
    coworker.old = 34;
    printf("old = %d\n", coworker.old);

    //для изменения строковых полей нужно воспользоваться ф-ей strcpy
    strcpy(coworker.fio.name, "Andrii");

    printf("name : %s\n",coworker.fio.name);

    //изменим любимые цифры
    int new_fav[num_length] = {1,2,3};
    coworker.fav_nums[0] = new_fav[0];
    coworker.fav_nums[1] = new_fav[1];
    coworker.fav_nums[2] = new_fav[2];

    for(int i = 0; i < num_length; ++i){
        printf("%d ", coworker.fav_nums[i]);
    }
    puts("");

    //или через memcpy

    int new_fav_2[num_length] = {100, 200, 300};
    memcpy(coworker.fav_nums, new_fav_2, sizeof(int) * num_length);
    for(int i = 0; i < num_length; ++i){
        printf("%d ", coworker.fav_nums[i]);
    }
    puts("");
    

    /*Интересно, что если мы внутрь структуры просто добавим некий массив, то тогда массивы
    мы можем тоже копировать друг в друга, используя операцию присваивания.
    Определим вверху структуры с массивом. Переменные должны быть одного типа(структуры)*/

    struct numbers my_array = {7,7,7};
    struct numbers my_array2;
    
    my_array2 = my_array;
    for(int i = 0; i < num_length; ++i){
        printf("%d ", my_array2.items[i]);
    }
    puts("");

    //массив полностью скопировался


    /*Объявление массивов из структур
    Допустим нам нужно хранить информацию по некой фигуре, которая описывается набором точек
    - вершин в трехмерном пространстве.
    И допустим для этого используется структура tag_dot (объявлена вверху).
    Теперь мы создадим массив из этих точек.
    */

    struct tag_dot all_dots[max_points];

    //определим переменную, которая будет определять из скольких точек будет состоять наша фигура
    int figure_points = 0;
    /*что мы тут получили? каждый индекс массива - это структура из трех координат x,y,z*/

    all_dots[0].x = 10;
    all_dots[0].y = 89;
    all_dots[0].z = 321;

    //это у нас таким образом заполнился первый элемент массива из структур
    //а вто так второй
    all_dots[1].x = 2;
    all_dots[1].y = 8;
    all_dots[1].z = 3;

    //вывод на экран
    for (int i = 0; i < max_points; ++i){
        for (int j = 0; j < max_points; ++j){
            printf("%.2f, %.2f, %.2f", all_dots[i].x, all_dots[i].y, all_dots[i].z);
        }
        puts("");
    }   


    //футболист
    struct footballer BukayoSaka = {
        "Bukayo Saka",
        "Winger R/L",
        "Arsenal FC",
        21
    };

    puts("--------------------------------------------------");
    printf("Player : %s\n", BukayoSaka.name);
    printf("Position: %s\n", BukayoSaka.position);
    printf("Current club : %s\n", BukayoSaka.club);
    printf("Age : %d\n", BukayoSaka.age);
    puts("--------------------------------------------------");



    return 0;
}