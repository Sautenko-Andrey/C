/*Функции с произвольным числом параметров*/

#include<stdio.h>
#include<stdarg.h>

float get_sum(int count, ...);
float get_money(float *deposit, int count, ...);

//ф-я , принимающая произвольное число аргументов и вычисляющаяих сумму
int sum(int count, ...)  //у ф-ии обязательно должен идти один параметр!
{
    //... - означают, что здесь может быть произвольное кол-во аргументов
    /*Мы хотим посчитать сумму величин, которые будут переданы в ...
    Мы предполагаем, что пользователь будет передавать целочисленные значения
    
    Объявим вспомагательную переменную,в которой будем хранить эту сумму*/

    int total = 0;
    /*Далее объявим специальный указатель, который имеет тип va_list*/
    va_list arg;  //тип va_list определен в stdarg

    /*далее нам нужно, чтобы указатель arg ссылался на первый вариадический параметр
    ... , т.е на первый параметр , который будет сюда передан.
    Для этого используется еще одна ф-я va_start - в нее мы передаем указаель arg
    и должны передать параметр, который стоит непосредственно перед ..., т.е count.
    Если будет несколько параметров, то нужно прописывать именно тот, который стоит
    перед ...  */
    va_start(arg, count);

    /*Ф-я va_start она инициализирует указатель arg на первый вариадический параметр,
    который может быть передан в ф-ию.
    А затем в цикле for мы переберем все вариадические парметры и посчитаем сумму
    значений.*/
    for(int i = 0; i < count; ++i){
        //внутри цикла считаем сумму
        /*Здесь будет еще одна ф-я va_arg , которая возвращает параметр, который мы пере-
        дали в функцию (...),причем обязятельно нужно указать тип этого параметра,
        потому что она не знает какой у этого параметра тип.
        Мы предполагаем, что он будет целочисленный*/
        total += va_arg(arg, int);
    }

        /*Ф-я va_arg возвращает значение текущего вариадического параметра и перемещает
        указатель на следующий вариадический параметр.
        Таким образом мы подсчитываем сумму. После того, как мы посчитали сумму и пере-
        брали все вариадические параметры, обязательно нужно вызвать ф-ию va_end(arg) 
        с аргументом arg(указатель).*/

    va_end(arg);
    return total;    
}

int main(void)
{
    /*Научимся объявлять и вызывать ф-ии с произвольным числом аргументов
    В качестве примера пропишем ф-ию , которая вычисляет сумму переданных ей 
    целочисленных значений.Подключим заголовочный файл stdarg.h , а сама функция объялена
    выше.
    Воспользуемся ф-ей sum()*/

    int result = sum(5, 1, 2, 3, 4, 5); //первая 5 - это count - общее кол-во вариадич.аргум.

    printf("result = %d\n", result);  //15

    //если же count мы укажем 3, то просумируются только первые три аргумента
    int res2 = sum(3, 1, 2, 3, 4, 5);
    printf("res2 = %d\n", res2);  //6

    /*Вариадические ф-ии редко используются на практике, потому что они неудобны.
    
    Если в будущем я планирую программировать не только на Си , но  и на С++,
    то важно знать еще две ключевые возможности именно языка С++,
    а именно:
    1- я возможность - это перегрузка функций. 
    2-я возможность - определение ф-ии с параметрами по умолчанию.

    Эти возможности используются исключтельно в С++.
    
    Чтобы показать эти возможности, нужна IDE с компилятором С++
    Поэтому тут будет закомементированный код.
    
    #include<iostream>

    int modul(int x)
    {
        return (x < 0) ? -x : x;
    }

    double modul(double x)
    {
        return (x < 0) ? -x : x;
    }
    
    int main(void)
    {   
        Перегрузка функций - позволяет нам определять функции с одинаковыми именами,
        у нас такие две ф-ии modul - у них одинаковые имена, но разные типы параметров
        этой ф-ии: в первой это int, а у второй - double.  Обе они вычисляют модуль числа.
        Соответственно обоими ими мы можем воспользоваться внутри ф-ии main следующим
        образом:

        int a1 = modul(-3);    //3
        int a2 = modul(-3.5);   //3
        double a3 = modul(-3);   //3.0
        double a4 = modul(-3.5);  //3.5

        Все отработало без проблем! Т.е получается, что мы можем объявить несколько ф-ий,
        с одними и теми же именами, а далее когда мы будем вызывать их в программе,
        компилятор уже сам решит какую из этих ф-ий использовать. Решает это компилятор
        просто: если в аргумент ф-ии передается целое значение, то вызывается ф-я с пара-
        метром, где определено это целое значение. Если же передается вещественный аргумент,
        соотвтет. вызывается ф-я с вещественным параметром.

        Зачем это нужно и почему нельхя объявить одну ф-ию с параметром double, тем самым
        сделав ее универсальной, ведь она может работать и с int.
        Но!Когда мы передаем в такую ф-ю int аргумент, он сначала конвертируется в double,
        а уже потом идет обработка внутри ф-ии. Это работает медленнее, чем если бы мы объя-
        вили для int свою ф-ию, а для double свою.

        А второе преимущество - функции с параметрами по умолчанию - мы можем в программе
        объявить ф-ии , у которой параметры будут сразу же принимать начальное значение.
        например вот такая ф-ия:

        void show_args(short a = 10, double b = 20.0, int c = 30)
        {
            printf("a = %d, b = %.2f, c = %d\n", a, b, c);
        }

        в ф-ии main ту ф-ию show_args можно вызвать вообще без каких-либо параметров:
        show_args(); - огда распечатает те значениея, которые указаны по умолчанию

        иди же передать аргументы:

        show_args(1);   - 1 будет подставлено в а вместо 10
        show_args(1,2);  a = 1, b = 2
        show_args(1,2,3); a = 1, b = 2, c = 3

        ЗДЕСЬ есть один ньюанс. Параметры по умолчанию должны идти в списке аргументов
        последними. Вначале должны прописываться обычные аргументы и только потом
        уже аргументы со значениями по умолчанию.

        return 0;
    }*/


    //практика
    float res3 = get_sum(3, 100.0, 100.0, 100.0, 5.0, 1);
    printf("res3 = %.2f\n", res3);

    //bank's ops
    float all_money = 1000.0f;
    get_money(&all_money, 2, 1.0, 2.0);
    printf("all_money = %.2f\n", all_money);




    return 0;
}

float get_sum(int count, ...)
{
    float sum = 0;
    va_list ptr;
    va_start(ptr, count);
    for(int i = 0; i<count;++i){
        sum += va_arg(ptr, double);
    }
    va_end(ptr);
    return sum;
}

float get_money(float *deposit, int count, ...)
{
    va_list ptr;
    va_start(ptr, count);
    for(int i = 0; i < count; ++i){
        *deposit -= va_arg(ptr, double);
    }
    va_end(ptr);
    return *deposit;
}