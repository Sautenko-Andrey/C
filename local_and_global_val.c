/* Локальные и глобальные переменные */

#include<stdio.h>
#include<string.h>


/*Внешний блок кода*/
char name[] = "Sautenko";
double array[10000000];  //будет работать

int global_var1 = 100;                     //допустимое объявление глобальной переменной
char global_var2[] = "Global";              //допустимое объявление глобальной переменной
double global_var3 = sizeof(array) - 1000;  //допустимое объявление глобальной переменной
const int global_var7 = 3;

//int global_var4 = global_var1;    //- ошибка!
int global_var5 = global_var7;      // а вот так уже можно,т.к const int global_var7

int main(void)
{   
    /*переменные в программе можно объявлять как внутри функции, так и за ее пределеами, и
    эти переменные ведут себя по-разному*/

    int value;  /*внутренняя переменная*/

    /*Начнем с локальных (внутренних переменных).
    Параметры и переменные, объяленные внутри тела функции существуют только в момент вызова
    этой функции и пропадают после ее завершения. Про такие переменные говорят, что они имеют
    область видимости в пределах функции и являются автоматическими, т.е автоматически
    создаются и автоматически уничтожаются.
    Кроме того, все переменные с такой ограниченной видимостью называются локальными.
    У нас задана локальная переменная value и она неинициализирована никаким значением.
    Какое значение она содержит - не известно (значение неопределенное), известно, чо она находится в стековом фрейме,
    и принимает какое-то значение(шум), мы можем в этом убедиться:*/
    printf("%d\n", value);  //какой-то шум

    /*И так обстоит дело со всеми локальными переменными, объвленными внутри тела функции.
    Все они размещаются в стековом фрейме и принимают начальные неопределенные значения.
    Нужно помнить,что стековый фрейм создается в момент запуска программы и имеет 
    ограниченный размер, поэтому нельзя объявлять локальные переменные огромные по размеру,
    к примеру массивы с миллионным кол-вом элементов.*/

    //double array[10000000]; - программа падает

    /*Это все происходит из-за того, что размер стекового фрейма ограничен.
    Вывод такой: логику программы нужно продумывать так, чтобы все локальные переменные
    играли служебную(вспомагательную роль), а не содержали огромные данные, подменяя собой БД.
    
    
    
    Иная картина вырисовывается для переменных, объявленных вне каких-либо функций.
    К примеру, если мы перенесем переменную double array[10000000] за пределы функций
    и запустим программу,то она не упадет и будет работать, в отличии от случая, когда 
    эту же переменную объявляли локально внутри функции.
    
    С чем связано такое поведение?
    Все переменные из внешнего блока размещаются в секции .bss - если эти переменные
    не инициализированы начальными значениями, либо в секции .data - если начальная
    инициализация присутствует.
    И эти секции .bss .data формируются в момент загрузки программы и размещаются
    непосредственно в оперативной памяти устройства, те их размер ограничивается только
    доступной памятью ПК и при этом они никак не связаны со стековым фреймом.
    Переменные, размещеные в секциях .bss и .data , появляются в момент загрузки программы
    и существуют на всем протяжении ее работы. Это означает, что область видимости этих
    переменных не ограничена и их можно совершенно спокойно использовать в любом месте
    программы как минимум в пределах текущего файла.
    Про такие переменные говорят, что они имеют глобальную область видимости.
    Секция .bss после размещения в памяти автоматически заполняется нулями, в результате все
    глобальные переменные, которые не инициализированы значениями , принимают занчения 0.
    А значения в секции .data формируются в результате загрузки в нее данных из исполняемого
    файла. Это очнеь удобно, потому что начальные значения инициализируются очень быстро,
    но есть некоторые ограничения - такие переменные можно инициализировать только 
    константными величинами и соответствующими выражениями.
    Прмеры смотри вверху.
    
    
    Несколько иначе обстоит дело с инициализацией локальных переменных.
    Т.к они формируются в процессе работы программы, а не при ее загрузке как это происходит
    с глобальными переменными, то их начальные значения можно определять любыми допустимыми
    значения языка Си, к примеру :*/

    int val = 100;
    int val2 = global_var1 + val*3;
    int size = sizeof(global_var2);

    /*Все эти варианты работают.
    
    ВАЖНО! Использование глобальных переменных при реализации логики программы - это очень плохая
    практика. Это связано с тем, что значения таких переменных можно менять в любом месте
    программы, в любой функции текущего файла. 
    В нормальной практике Си и С++  глобальные переменные используются для определения набора
    констант числовых или строковых.
    
    Возникает вопрос, как тогда в программе хранить данные большого размера, если для этого
    нельзя использовать стековый фрейм и глобальные переменные?
    ДЛя таки х целей, когда данные занимают от нескольких сот килобайт и более, лучше
    самостоятельно выделять нужный объем памяти, а затем освобождать ее.
    Это можно сделать с помощью ф-ий malloc() и free(), о которых еще будем говорить.
    А пока важно запомнить, что обычные перменные для хранения больших данных лучше не исполь-
    зовать.*/


    return 0;
}