/*Перечисления (enum). Директива typedef*/

#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//вариант определения констант
#define RED 0
#define GREEN 1
#define BLUE 2

//еще один вариант определения констант
const int c_red = 0;
const int c_green = 1;
const int c_blue = 2;


/*С помощью перечесления enum удобно определять набор целочисленных констант.*/
enum colors {red, green, blue};   // 0,1,2

/*константы в перечислении с заданными значениями*/
enum keys {fb_key = 14, ig_key = 11, yt_key = 23}; //14, 11, 23

/*смешанное объявление*/
enum footballers {saka = 7, odegaard = 8, jesus, martinelli = 11}; //7, 8, 9, 11

//или вот так
enum numbers {one = 1, two, three, four, five}; // 1, 2, 3, 4, 5

//мы можем прописывать значения и в 16-ричной форме счсления
enum {
    go = 0x1f00,
    stop = 0x0001,
    forward = go + 1,
    back = go - stop,
    run = go * go
};


//пример объявления глобальной переменной перечисляемого типа
enum days {monday, thuesday, wednesday, thursday, friday, saturday, sunday} week_day;

//можно через запятую определить две разных переменных
//здесь в enum отсутствует имя, определены только константы и к тому же сразу две переменные
enum {
    ivanko,
    yrko,
    chausko,
    makako,
    shevko
} man, woman;

//применение директивы typedf
//мы заменим тип unsigned char именем BYTE
//чтобы в программе вместо типа unsigned char мы могли записывать BYTE
typedef unsigned char BYTE;

//определим указатель с помощью define
#define PTR_INT int*

//тоже самое сделаем с помощью директивы typedef
typedef int* PTR;

//подмена enum с помощтю typedef
typedef enum {
    height = 192,
    weight = 85,
    age = 33
} PLAYER_PARAMS_CONST;

int is_even(int x)
{
    return x % 2 == 0;
}

//сделаем указатель на этот тип данных с помощью подмены
typedef int (*PTR_EVEN)(int);

//сделаем указатель на двумерный массив
typedef char (*PTR_2D)[4];  //вторая размерность как и у массива,для которого делаем указатель

int main(void)
{
    /*Зачем нужно это перечисление?
    Можно же было определить эти константы через define или в крайнем случае через const.
    
    На самом деле константы в перечислениях enum отличаются от всего того, что нам было известно
    на данный момент.
    
    От константных переменных const int c_red = 0; их отличает то, что значения констант
     {red, green, blue} формируются в момент компиляции программы.Т.е константы в перечислениях
    являются константами времени компиляции. В частности по этой причине такие константы
    можно использовать в метках условного оператора switch.

    А от директив #define BLUE 2 такие контстанты отличает безопасность их использования в различ-
    ных конструкциях языка Си. Именно по-этому такие константы записывают малыми буквами, а не
    большими как мы это делаем в директивах.

    Все это делает перечисления незаменимым инструментом для объявления и использования целочис-
    ленных констант.

    Далее рассмотрим способы объявления перечислений.

    В базовом варианте значения констант уже заданы по аналогии с индексами массивов, посомтрим на них:
    */
    printf("red = %d, green = %d, blue = %d\n", red, green, blue); //0,1,2

    /*При необходимости мы можем сами задавать значения для этих констант, смотри объявление
    вверху!
    
    Рассмотрим как используются эти перечисления непосредственно в программах.*/

    enum footballers player = martinelli;  //int

    /*переменная player в данном случаем имеет тип enum footballers*/

    switch (player)
    {
    case saka:
        puts("Bukayo Saka");
        break;
    case odegaard:
        puts("Martin Odegaard");
        break;
    case jesus:
        puts("Gabriel Jesus");
        break;
    case martinelli:
        puts("Gabriel Martinelli");
        break;
    }
    
    /*Перечисление, которое мы здесь используем дает возможность компилятору точнее анализировать
    программу на возможные ошибки. Потому что если бы мы не включили в кейс ходтя бы одного игрока
    из нашего перечисления, то компилятор бы сообщил об ошибке, посчитав, что мы попросту забыли
    указать этого игрока из нашего перечисления в условном операторе switch
    
    А во всем остальном переменная player ведет себя как и обычная целочисленная переменная.
    
    Переменную player лучше всего использовать по назначению и присваивать ей значение,
    которое прописано в виде констант в перечислении.
    
    Если нам нужно определить не локальную переменную перечисляемого типа, а глобальную, то можно 
    сделать так как в примере вверху.
    
    
    В общем случае синтаксис для определения перечислений выглядит вот так:
    
    enum[идентификатор]{набор констант};


    Далее рассмотрим директиву typedef,которая позволяет задавать пользовательское имя типа.
    Попросту говоря она любой тип данных позволяет представлять другим именем.
    пример смотри вверху
    */
    BYTE my_age;  //переменная типа BYTE (unsigned char на самом деле)

    /*Ключевое отличие директивы typedef от define заключается в том, что она обрабатывается
    не препроцессором, а самим компилятором.
    Поэтому это более тонкое и безопасное действие.
    Рассмотрим пример.*/

    //воспользуемся директивой PTR_INT.предполагаем что a и b - указатели
    PTR_INT a, b;

    //воспользуемся директивой PTR.предполагаем, что ptr_a, ptr_b - указатели
    PTR ptr_a, ptr_b;  // int *ptr_a , int *ptr_b

    /*Есть ли отличия в этих двух строчках?
    Если мы наведем мышкой на a, то увидим,что это действительно указатель, а вот b -нет.
    Это потому что директива define действует в лоб, т.е она а назначила указателем, а b нет -
    будет обычное целочисленное число.Поэтому с помощью лирективы define два указатля объявить
    не получится.
    
    А вот typedef как раз справляется с этим и обе переменные ptr_a, ptr_b являются указателями.
    
    Вывод: подмены всегда делать лучше через директиву typedef ,которая работает на уровне
    компилятора , а не на уровне препроцессора как define!

    Довольно часто директиву typedef применяют для определения составного типа.Чтобы постоянно не
    писать enam...мы можем подменить его имя другим. Смотри пример вверху!
    
    определим константу типа PLAYER_PARAMS и присвоим ей значение любой константы*/
    PLAYER_PARAMS_CONST my_height = height;
    printf("my height = %d\n", my_height);

    /*Тут уже человеческий и интуитивно понятный тип данных*/
    
    /*ЗАЧЕМ ВСЕ ЭТО НУЖНО?
    Раньше мы встречались с типом данных size_t. В действительности - это переопреденный тип
    unsigned int с помощью typedef.
    
    typedef дает нам некую универсальность в написании программ и так же упрощает запись
    сложных типов данных в программах таких как указатели на функции или многомерные массивы.
    
    Представим, что у нас есть ф-я, возвращающая 1 для четного значения и 0 для нечетного и 
    она определена вверху.  И нам бы хотелось в программе иметь указатель на этот тип данных.
    Прописывать этот указаетль не очень удобно в явном виде, поэтому сделаем подмену
    с помощью typedef*/

    //создадим указатель на эту функцию
    PTR_EVEN func_even = is_even;

    //и теперь эту функцию можно вызвать через этот указатель
    printf("%d\n", func_even(2));  //1 - то есть четное
    printf("%d\n", func_even(3));  //0 - нечетное


    //или у нас есть двумерный массив 5х4 заполенный нулями
    char numbers_2D[5][4] = {0};
    //мы хотим иметь указатель на этот массив
    //прописывать его в явном виде не очень удобно
    //с помощью typedef верху сделаем трюк
    PTR_2D ptr_numbers_2D = numbers_2D;
    //теперь через этот указатель мы можем спокойно рабоать с массивом
    ptr_numbers_2D[0][0] = 100;

    //выведем значения массива на экран
    for(int i = 0; i < 5; ++i){
        for(int j = 0; j < 4; ++j){
            printf("%d ", numbers_2D[i][j]);
        }
        putchar('\n');
    }

    //результат
    /*
    100 0 0 0
      0 0 0 0
      0 0 0 0
      0 0 0 0
      0 0 0 0
    */


    return 0;
}